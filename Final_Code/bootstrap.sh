#!/usr/bin/env bash
# Shebang라인, 스크립트가 bash로 실행되도록 지정함 

PS1=${PS1-}
# PS1(프롬프트 변수)이 설정되지 않은 경우, 빈 문자열로 초기화함
set -euo pipefail
# 스크립트의 안정성과 오류 탐지를 강화, 예상치 못한 상황에서 스크립트가 중단되도록 함(-e: 명령어 실패 시 종료, -u: 정의되지 않은 변수 사용 시 오류 발생, -o pipefail: 파이프라인 내 명령어 실패 시 전체 파이프라인 실패로 간주)

# --- locate aws cli across MSYS2 / Windows ---
AWS_CLI_BIN="${AWS_CLI_BIN-}"  # allow override from env
# 기존에 설정된 AWS_CLI_BIN 환경 변수를 사용하거나, 빈 문자열로 초기화함
if [ -z "${AWS_CLI_BIN}" ]; then # AWS_CLI_BIN이 비어있거나 설정되지 않은 경우; -z 옵션: 변수가 비어있거나, 정의되지 않은 경우 true 반환
  if command -v aws >/dev/null 2>&1; then # aws 명령어가 시스템 경로에 존재하는지 확인함; command -v: 명령어의 경로를 출력함, >/dev/null 2>&1: 표준 출력과 표준 오류를 모두 버림
    AWS_CLI_BIN="aws"
  elif [ -x "/c/Program Files/Amazon/AWSCLIV2/aws.exe" ]; then # Windows의 기본 설치 경로에 AWS CLI가 존재하는지 확인함; -x 옵션: 파일이 존재하고, 실행 가능한 경우 true 반환
    AWS_CLI_BIN="/c/Program Files/Amazon/AWSCLIV2/aws.exe"
  elif [ -x "/c/Program Files/Amazon/AWSCLI/aws.exe" ]; then
    AWS_CLI_BIN="/c/Program Files/Amazon/AWSCLI/aws.exe"
  else
    echo "❌ Cannot find AWS CLI. Install it or set AWS_CLI_BIN to full path (e.g. /c/Program Files/Amazon/AWSCLIV2/aws.exe)" >&2
    exit 1
  fi
fi
AWS_CLI="$AWS_CLI_BIN"
# --- end locate aws cli ---

# 로그 파일 (원하는 경로로 바꿔도 됨)
LOG_DIR="${LOG_DIR:-./logs}"
mkdir -p "$LOG_DIR"
LOG_FILE="${LOG_FILE:-$LOG_DIR/bootstrap_$(date +%Y%m%d_%H%M%S).log}"

# ── 에러 트랩: 실패 라인/명령/리턴코드 출력 + 셸 유지 ───────────────
trap 'rc=$?; echo; echo "❌ ERROR: line $LINENO while running: $BASH_COMMAND (exit=$rc)"; \
      echo "👉 Full log: $LOG_FILE"; \
      echo "Dropping you into interactive shell (type: exit to quit)"; \
      PS1="(debug) $PS1" bash --noprofile --norc; exit $rc' ERR

# 모든 출력 로그로 저장 (화면에도 출력)
exec > >(tee -a "$LOG_FILE") 2>&1

# 디버그(원하면 주석 해제)
# set -x


echo "== Bootstrap started $(date) =="


# One‑stop automation script for provisioning AWS resources with Terraform
# and deploying the shopping‑mall application to an EKS cluster via a
# bastion host.  This script assumes you have valid AWS credentials
# configured on your local machine (via environment variables or the
# default AWS config files) and that you have a working SSH key for
# connecting to the bastion instance.  The bastion instance will
# perform container image builds and pushes, then apply the Kubernetes
# manifests to the newly created cluster.

# --------------------------------------------------------------------
# Configuration
#
# The following environment variables can be overridden to customise
# the behaviour of this script.  You can export them in your shell or
# define them in an env.sh file which will be sourced automatically
# when present.
#
# TF_DIR          – path to the Terraform directory (default: ./terraform)
# APP_DIR         – path to the application source directory containing
#                    the k8s manifests and Docker build contexts
# REGION          – AWS region (default: ap-northeast-2)
# IMAGE_TAG       – tag to apply to the built Docker images (default: latest)
# SSH_KEY         – path to the private key for SSH into the bastion
# SSH_USER        – user name to use for SSH (default: ec2-user)
# USE_ECR_SECRET  – set to "true" to create a Kubernetes image pull
#                    secret and attach it to the service account
#
# DB_MASTER_USERNAME, DB_MASTER_PASSWORD, DB_NAME – credentials for
# the RDS database.  These must match the values used in your
# terraform.tfvars.  They are used to build the SQLAlchemy URI for
# the backend service.
#
# JWT_SECRET_KEY  – optional pre‑seeded JWT secret.  If omitted a
# random value will be generated by the remote script.
#
# FQDN            – fully qualified domain name for the ingress host.
#
# You can set these variables in an env.sh file in the same directory
# as this script.  That file is ignored by git so you can store
# secrets there safely.  See env.sh.example for a starting point.
# --------------------------------------------------------------------

# Source user‑defined environment variables if present
# 동일 경로 상에 env.sh 파일이 존재하면, 그 파일을 현재 스크립트에 포함시켜서 환경 변수들을 설정함
if [[ -f "$(dirname "$0")/env.sh" ]]; then
  # shellcheck disable=SC1090
 source "$(dirname "$0")/env.sh"
fi

# Apply defaults
# 아래를 기본값으로 설정 
REGION=${REGION:-"ap-northeast-2"} 
TF_DIR=${TF_DIR:-"./terra"} # tf파일 위치 
APP_DIR=${APP_DIR:-"./bastion_scripts"} # bastion에 전달할 파일 위치 
IMAGE_TAG=${IMAGE_TAG:-"latest"}
SSH_USER=${SSH_USER:-"ec2-user"}
SSH_KEY=${SSH_KEY:-"./LetMeIn.pem"} # Bastion 접속을 위한 SSH 키 
DB_MASTER_USERNAME=${DB_MASTER_USERNAME:-"admin"}
DB_MASTER_PASSWORD=${DB_MASTER_PASSWORD:-"passWord"}
DB_NAME=${DB_NAME:-"shopdb"}
FQDN=${FQDN:-"shop.gyowoon.shop"}
JWT_SECRET_KEY=${JWT_SECRET_KEY:-""}    # 옵션. 빈 값이면 자동으로 생성



# Resolve required variables -> 필수 변수 확인(SSH Key, DB관련 변수)
## z 옵션: 변수가 비어있거나, 정의되지 않은 경우 true 반환 
if [[ -z "${SSH_KEY:-}" ]]; then
  echo "ERROR: SSH_KEY environment variable must be set to the path of your bastion SSH private key" >&2
  exit 1
fi
if [[ -z "${DB_MASTER_USERNAME:-}" || -z "${DB_MASTER_PASSWORD:-}" || -z "${DB_NAME:-}" ]]; then
  echo "ERROR: DB_MASTER_USERNAME, DB_MASTER_PASSWORD and DB_NAME must be set to match your terraform.tfvars" >&2
  exit 1
fi

# Ensure the SSH key exists
## f 옵션: 파일이 존재하고, 일반 파일인 경우 true 반환
if [[ ! -f "$SSH_KEY" ]]; then
  echo "ERROR: SSH key file $SSH_KEY not found" >&2
  exit 1
fi

# Convenience function to print headings
heading() {
  echo
  echo "==================== $1 ====================="
}

# 1. Remove orphaned resources and apply Terraform configuration
heading "Cleaning up state and applying configuration"

# First remove the orphaned kubernetes_config_map from state
terraform -chdir="$TF_DIR" state rm module.bastion.kubernetes_config_map.aws_auth 2>/dev/null || true

# Check if bastion module exists in state
if terraform -chdir="$TF_DIR" state list | grep -q "module.bastion"; then
  heading "Destroying existing Bastion instance"
  terraform -chdir="$TF_DIR" destroy -target=module.bastion -auto-approve
else
  heading "No existing Bastion instance found"
fi

heading "Running terraform apply"
terraform -chdir="$TF_DIR" init -upgrade
terraform -chdir="$TF_DIR" apply -auto-approve

# 2. Retrieve outputs we need
## 테라폼 실행 output들을 raw 문자값으로, 변수화시키고 터미널로 출력 
heading "Collecting terraform outputs"
CLUSTER_NAME=$(terraform -chdir="$TF_DIR" output -raw cluster_name)
BASTION_IP=$(terraform -chdir="$TF_DIR" output -raw bastion_public_ip)
RDS_ENDPOINT=$(terraform -chdir="$TF_DIR" output -raw rds_endpoint)
REDIS_ENDPOINT=$(terraform -chdir="$TF_DIR" output -raw redis_endpoint)

echo "Cluster name     : $CLUSTER_NAME"
echo "Bastion public IP: $BASTION_IP"
echo "RDS endpoint     : $RDS_ENDPOINT"
echo "Redis endpoint   : $REDIS_ENDPOINT"

# 3. Determine AWS account ID for ECR registry construction
## ECR 접속을 위한 AWS 계정 ID 조회
ACCOUNT_ID=$("$AWS_CLI" sts get-caller-identity --query Account --output text)
ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com"
echo "AWS Account ID   : $ACCOUNT_ID"

# 4. Copy application artiafacts and prepare remote script
## rsync를 이용해서 Bastion에 전달할, 배포가능한 빌드용 RAW파일(Front/BackEnd)/산출물/k8s Manifest(YAMLS)들을 의미함
heading "Uploading application artefacts to bastion"

# The application directory is expected to contain unpacked folders named
# k8s, backend and frontend.  If these folders are missing we abort.

if [[ ! -d "$APP_DIR" ]]; then
  echo "ERROR: directory $APP_DIR/ not found.  Please ensure your app source directory contains the uncompressed folders." >&2
  exit 1
fi


# Copy the unpacked application folders to the bastion host.  We use rsync
# with --delete to ensure the remote directories exactly mirror the local
# ones.  The trailing slash on the source ensures that rsync copies the
# contents into the destination directory rather than creating a nested
# folder.
## Send some of mainfests(YAML) and RAW F/E & B/E Files from Local to Bastion 


SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
## -o StrictHostKeyChecking=no: SSH가 처음 접속하는 호스트의 키를 자동으로 신뢰하도록 설정함
## -o UserKnownHostsFile=/dev/null: 호스트 키를 저장하지 않도록 설정함(보안상 위험할 수 있음)

# verbose SSH 연결 시도
#ssh -vvv -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i "$SSH_KEY" "$SSH_USER@$BASTION_IP" "whoami; pwd; ls -la ~/"


rsync -avz -e "ssh $SSH_OPTS -i $SSH_KEY" "$APP_DIR/" "${SSH_USER}@${BASTION_IP}:~/" >/dev/null

# 5. Write a file containing environment variables to the bastion.  When
# you SSH into the bastion you can source this file to reuse the
# Terraform outputs and other settings.  Note that sensitive values
# like DB credentials are included, so treat this file with care.
## Send some of tfstate Output from Local to Bastion 
heading "Copying environment variables to bastion"
cat > /tmp/bastion_env.sh <<EOF
export REGION=${REGION}
export CLUSTER_NAME=${CLUSTER_NAME}
export ACCOUNT_ID=${ACCOUNT_ID}
export IMAGE_TAG=${IMAGE_TAG}
export ECR_REGISTRY=${ECR_REGISTRY}
export RDS_ENDPOINT=${RDS_ENDPOINT}
export REDIS_ENDPOINT=${REDIS_ENDPOINT}
export DB_MASTER_USERNAME=${DB_MASTER_USERNAME}
export DB_MASTER_PASSWORD=${DB_MASTER_PASSWORD}
export DB_NAME=${DB_NAME}
export JWT_SECRET_KEY=${JWT_SECRET_KEY:-}
aws eks update-kubeconfig --region "$REGION" --name "$CLUSTER_NAME" --alias "$CLUSTER_NAME"

EOF
#scp -i "$SSH_KEY" /tmp/bastion_env.sh "${SSH_USER}@${BASTION_IP}:~/0_env.sh" >/dev/null
#ssh -i "$SSH_KEY" "${SSH_USER}@${BASTION_IP}" "chmod 600 ~/0_env.sh"

# scp로 실행 시점에 생성된 환경변수 관련 파일을 Bastion으로 전달
scp $SSH_OPTS -i "$SSH_KEY" /tmp/bastion_env.sh "${SSH_USER}@${BASTION_IP}:~/0_env.sh"

# ssh로 Bastion에 접속하여, 전달된 환경변수 관련 파일의 권한을 600으로 변경
ssh $SSH_OPTS -i "$SSH_KEY" "${SSH_USER}@${BASTION_IP}" "chmod 600 ~/0_env.sh"

## Bootstrap Finish Notice 
heading "Bootstrap completed"
echo "Terraform apply and file transfers are complete.  Please SSH into the bastion host (${BASTION_IP}) and source ~/env.sh to load the environment variables.  You can then run ~/remote_deploy.sh manually or execute commands interactively to deploy your application."
